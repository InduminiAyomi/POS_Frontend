{"ast":null,"code":"'use strict';\n\nfunction _interopDefault(ex) {\n  return ex && typeof ex === 'object' && 'default' in ex ? ex['default'] : ex;\n}\n\nvar _JSXStyle = _interopDefault(require('styled-jsx/style'));\n\nvar React = require('react');\n\nvar React__default = _interopDefault(React);\n\nvar reactFontawesome = require('@fortawesome/react-fontawesome');\n\nvar freeSolidSvgIcons = require('@fortawesome/free-solid-svg-icons');\n\nfunction _classCallCheck(instance, Constructor) {\n  if (!(instance instanceof Constructor)) {\n    throw new TypeError(\"Cannot call a class as a function\");\n  }\n}\n\nfunction _defineProperties(target, props) {\n  for (var i = 0; i < props.length; i++) {\n    var descriptor = props[i];\n    descriptor.enumerable = descriptor.enumerable || false;\n    descriptor.configurable = true;\n    if (\"value\" in descriptor) descriptor.writable = true;\n    Object.defineProperty(target, descriptor.key, descriptor);\n  }\n}\n\nfunction _createClass(Constructor, protoProps, staticProps) {\n  if (protoProps) _defineProperties(Constructor.prototype, protoProps);\n  if (staticProps) _defineProperties(Constructor, staticProps);\n  return Constructor;\n}\n\nfunction _defineProperty(obj, key, value) {\n  if (key in obj) {\n    Object.defineProperty(obj, key, {\n      value: value,\n      enumerable: true,\n      configurable: true,\n      writable: true\n    });\n  } else {\n    obj[key] = value;\n  }\n\n  return obj;\n}\n\nfunction _extends() {\n  _extends = Object.assign || function (target) {\n    for (var i = 1; i < arguments.length; i++) {\n      var source = arguments[i];\n\n      for (var key in source) {\n        if (Object.prototype.hasOwnProperty.call(source, key)) {\n          target[key] = source[key];\n        }\n      }\n    }\n\n    return target;\n  };\n\n  return _extends.apply(this, arguments);\n}\n\nfunction _inherits(subClass, superClass) {\n  if (typeof superClass !== \"function\" && superClass !== null) {\n    throw new TypeError(\"Super expression must either be null or a function\");\n  }\n\n  subClass.prototype = Object.create(superClass && superClass.prototype, {\n    constructor: {\n      value: subClass,\n      writable: true,\n      configurable: true\n    }\n  });\n  if (superClass) _setPrototypeOf(subClass, superClass);\n}\n\nfunction _getPrototypeOf(o) {\n  _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) {\n    return o.__proto__ || Object.getPrototypeOf(o);\n  };\n  return _getPrototypeOf(o);\n}\n\nfunction _setPrototypeOf(o, p) {\n  _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) {\n    o.__proto__ = p;\n    return o;\n  };\n\n  return _setPrototypeOf(o, p);\n}\n\nfunction _objectWithoutPropertiesLoose(source, excluded) {\n  if (source == null) return {};\n  var target = {};\n  var sourceKeys = Object.keys(source);\n  var key, i;\n\n  for (i = 0; i < sourceKeys.length; i++) {\n    key = sourceKeys[i];\n    if (excluded.indexOf(key) >= 0) continue;\n    target[key] = source[key];\n  }\n\n  return target;\n}\n\nfunction _objectWithoutProperties(source, excluded) {\n  if (source == null) return {};\n\n  var target = _objectWithoutPropertiesLoose(source, excluded);\n\n  var key, i;\n\n  if (Object.getOwnPropertySymbols) {\n    var sourceSymbolKeys = Object.getOwnPropertySymbols(source);\n\n    for (i = 0; i < sourceSymbolKeys.length; i++) {\n      key = sourceSymbolKeys[i];\n      if (excluded.indexOf(key) >= 0) continue;\n      if (!Object.prototype.propertyIsEnumerable.call(source, key)) continue;\n      target[key] = source[key];\n    }\n  }\n\n  return target;\n}\n\nfunction _assertThisInitialized(self) {\n  if (self === void 0) {\n    throw new ReferenceError(\"this hasn't been initialised - super() hasn't been called\");\n  }\n\n  return self;\n}\n\nfunction _possibleConstructorReturn(self, call) {\n  if (call && (typeof call === \"object\" || typeof call === \"function\")) {\n    return call;\n  }\n\n  return _assertThisInitialized(self);\n}\n\nfunction _toConsumableArray(arr) {\n  return _arrayWithoutHoles(arr) || _iterableToArray(arr) || _nonIterableSpread();\n}\n\nfunction _arrayWithoutHoles(arr) {\n  if (Array.isArray(arr)) {\n    for (var i = 0, arr2 = new Array(arr.length); i < arr.length; i++) {\n      arr2[i] = arr[i];\n    }\n\n    return arr2;\n  }\n}\n\nfunction _iterableToArray(iter) {\n  if (Symbol.iterator in Object(iter) || Object.prototype.toString.call(iter) === \"[object Arguments]\") return Array.from(iter);\n}\n\nfunction _nonIterableSpread() {\n  throw new TypeError(\"Invalid attempt to spread non-iterable instance\");\n}\n\nfunction createCommonjsModule(fn, module) {\n  return module = {\n    exports: {}\n  }, fn(module, module.exports), module.exports;\n}\n/*\nobject-assign\n(c) Sindre Sorhus\n@license MIT\n*/\n\n/* eslint-disable no-unused-vars */\n\n\nvar getOwnPropertySymbols = Object.getOwnPropertySymbols;\nvar hasOwnProperty = Object.prototype.hasOwnProperty;\nvar propIsEnumerable = Object.prototype.propertyIsEnumerable;\n\nfunction toObject(val) {\n  if (val === null || val === undefined) {\n    throw new TypeError('Object.assign cannot be called with null or undefined');\n  }\n\n  return Object(val);\n}\n\nfunction shouldUseNative() {\n  try {\n    if (!Object.assign) {\n      return false;\n    } // Detect buggy property enumeration order in older V8 versions.\n    // https://bugs.chromium.org/p/v8/issues/detail?id=4118\n\n\n    var test1 = new String('abc'); // eslint-disable-line no-new-wrappers\n\n    test1[5] = 'de';\n\n    if (Object.getOwnPropertyNames(test1)[0] === '5') {\n      return false;\n    } // https://bugs.chromium.org/p/v8/issues/detail?id=3056\n\n\n    var test2 = {};\n\n    for (var i = 0; i < 10; i++) {\n      test2['_' + String.fromCharCode(i)] = i;\n    }\n\n    var order2 = Object.getOwnPropertyNames(test2).map(function (n) {\n      return test2[n];\n    });\n\n    if (order2.join('') !== '0123456789') {\n      return false;\n    } // https://bugs.chromium.org/p/v8/issues/detail?id=3056\n\n\n    var test3 = {};\n    'abcdefghijklmnopqrst'.split('').forEach(function (letter) {\n      test3[letter] = letter;\n    });\n\n    if (Object.keys(Object.assign({}, test3)).join('') !== 'abcdefghijklmnopqrst') {\n      return false;\n    }\n\n    return true;\n  } catch (err) {\n    // We don't expect any of the above to throw, but better to be safe.\n    return false;\n  }\n}\n\nvar objectAssign = shouldUseNative() ? Object.assign : function (target, source) {\n  var from;\n  var to = toObject(target);\n  var symbols;\n\n  for (var s = 1; s < arguments.length; s++) {\n    from = Object(arguments[s]);\n\n    for (var key in from) {\n      if (hasOwnProperty.call(from, key)) {\n        to[key] = from[key];\n      }\n    }\n\n    if (getOwnPropertySymbols) {\n      symbols = getOwnPropertySymbols(from);\n\n      for (var i = 0; i < symbols.length; i++) {\n        if (propIsEnumerable.call(from, symbols[i])) {\n          to[symbols[i]] = from[symbols[i]];\n        }\n      }\n    }\n  }\n\n  return to;\n};\n/**\n * Copyright (c) 2013-present, Facebook, Inc.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n */\n\nvar ReactPropTypesSecret = 'SECRET_DO_NOT_PASS_THIS_OR_YOU_WILL_BE_FIRED';\nvar ReactPropTypesSecret_1 = ReactPropTypesSecret;\n\nvar printWarning = function printWarning() {};\n\n{\n  var ReactPropTypesSecret$1 = ReactPropTypesSecret_1;\n  var loggedTypeFailures = {};\n\n  printWarning = function printWarning(text) {\n    var message = 'Warning: ' + text;\n\n    if (typeof console !== 'undefined') {\n      console.error(message);\n    }\n\n    try {\n      // --- Welcome to debugging React ---\n      // This error was thrown as a convenience so that you can use this stack\n      // to find the callsite that caused this warning to fire.\n      throw new Error(message);\n    } catch (x) {}\n  };\n}\n/**\n * Assert that the values match with the type specs.\n * Error messages are memorized and will only be shown once.\n *\n * @param {object} typeSpecs Map of name to a ReactPropType\n * @param {object} values Runtime values that need to be type-checked\n * @param {string} location e.g. \"prop\", \"context\", \"child context\"\n * @param {string} componentName Name of the component for error messages.\n * @param {?Function} getStack Returns the component stack.\n * @private\n */\n\nfunction checkPropTypes(typeSpecs, values, location, componentName, getStack) {\n  {\n    for (var typeSpecName in typeSpecs) {\n      if (typeSpecs.hasOwnProperty(typeSpecName)) {\n        var error; // Prop type validation may throw. In case they do, we don't want to\n        // fail the render phase where it didn't fail before. So we log it.\n        // After these have been cleaned up, we'll let them throw.\n\n        try {\n          // This is intentionally an invariant that gets caught. It's the same\n          // behavior as without this statement except with a better message.\n          if (typeof typeSpecs[typeSpecName] !== 'function') {\n            var err = Error((componentName || 'React class') + ': ' + location + ' type `' + typeSpecName + '` is invalid; ' + 'it must be a function, usually from the `prop-types` package, but received `' + typeof typeSpecs[typeSpecName] + '`.');\n            err.name = 'Invariant Violation';\n            throw err;\n          }\n\n          error = typeSpecs[typeSpecName](values, typeSpecName, componentName, location, null, ReactPropTypesSecret$1);\n        } catch (ex) {\n          error = ex;\n        }\n\n        if (error && !(error instanceof Error)) {\n          printWarning((componentName || 'React class') + ': type specification of ' + location + ' `' + typeSpecName + '` is invalid; the type checker ' + 'function must return `null` or an `Error` but returned a ' + typeof error + '. ' + 'You may have forgotten to pass an argument to the type checker ' + 'creator (arrayOf, instanceOf, objectOf, oneOf, oneOfType, and ' + 'shape all require an argument).');\n        }\n\n        if (error instanceof Error && !(error.message in loggedTypeFailures)) {\n          // Only monitor this failure once because there tends to be a lot of the\n          // same error.\n          loggedTypeFailures[error.message] = true;\n          var stack = getStack ? getStack() : '';\n          printWarning('Failed ' + location + ' type: ' + error.message + (stack != null ? stack : ''));\n        }\n      }\n    }\n  }\n}\n\nvar checkPropTypes_1 = checkPropTypes;\n\nvar printWarning$1 = function printWarning$1() {};\n\n{\n  printWarning$1 = function printWarning$1(text) {\n    var message = 'Warning: ' + text;\n\n    if (typeof console !== 'undefined') {\n      console.error(message);\n    }\n\n    try {\n      // --- Welcome to debugging React ---\n      // This error was thrown as a convenience so that you can use this stack\n      // to find the callsite that caused this warning to fire.\n      throw new Error(message);\n    } catch (x) {}\n  };\n}\n\nfunction emptyFunctionThatReturnsNull() {\n  return null;\n}\n\nvar factoryWithTypeCheckers = function factoryWithTypeCheckers(isValidElement, throwOnDirectAccess) {\n  /* global Symbol */\n  var ITERATOR_SYMBOL = typeof Symbol === 'function' && Symbol.iterator;\n  var FAUX_ITERATOR_SYMBOL = '@@iterator'; // Before Symbol spec.\n\n  /**\n   * Returns the iterator method function contained on the iterable object.\n   *\n   * Be sure to invoke the function with the iterable as context:\n   *\n   *     var iteratorFn = getIteratorFn(myIterable);\n   *     if (iteratorFn) {\n   *       var iterator = iteratorFn.call(myIterable);\n   *       ...\n   *     }\n   *\n   * @param {?object} maybeIterable\n   * @return {?function}\n   */\n\n  function getIteratorFn(maybeIterable) {\n    var iteratorFn = maybeIterable && (ITERATOR_SYMBOL && maybeIterable[ITERATOR_SYMBOL] || maybeIterable[FAUX_ITERATOR_SYMBOL]);\n\n    if (typeof iteratorFn === 'function') {\n      return iteratorFn;\n    }\n  }\n  /**\n   * Collection of methods that allow declaration and validation of props that are\n   * supplied to React components. Example usage:\n   *\n   *   var Props = require('ReactPropTypes');\n   *   var MyArticle = React.createClass({\n   *     propTypes: {\n   *       // An optional string prop named \"description\".\n   *       description: Props.string,\n   *\n   *       // A required enum prop named \"category\".\n   *       category: Props.oneOf(['News','Photos']).isRequired,\n   *\n   *       // A prop named \"dialog\" that requires an instance of Dialog.\n   *       dialog: Props.instanceOf(Dialog).isRequired\n   *     },\n   *     render: function() { ... }\n   *   });\n   *\n   * A more formal specification of how these methods are used:\n   *\n   *   type := array|bool|func|object|number|string|oneOf([...])|instanceOf(...)\n   *   decl := ReactPropTypes.{type}(.isRequired)?\n   *\n   * Each and every declaration produces a function with the same signature. This\n   * allows the creation of custom validation functions. For example:\n   *\n   *  var MyLink = React.createClass({\n   *    propTypes: {\n   *      // An optional string or URI prop named \"href\".\n   *      href: function(props, propName, componentName) {\n   *        var propValue = props[propName];\n   *        if (propValue != null && typeof propValue !== 'string' &&\n   *            !(propValue instanceof URI)) {\n   *          return new Error(\n   *            'Expected a string or an URI for ' + propName + ' in ' +\n   *            componentName\n   *          );\n   *        }\n   *      }\n   *    },\n   *    render: function() {...}\n   *  });\n   *\n   * @internal\n   */\n\n\n  var ANONYMOUS = '<<anonymous>>'; // Important!\n  // Keep this list in sync with production version in `./factoryWithThrowingShims.js`.\n\n  var ReactPropTypes = {\n    array: createPrimitiveTypeChecker('array'),\n    bool: createPrimitiveTypeChecker('boolean'),\n    func: createPrimitiveTypeChecker('function'),\n    number: createPrimitiveTypeChecker('number'),\n    object: createPrimitiveTypeChecker('object'),\n    string: createPrimitiveTypeChecker('string'),\n    symbol: createPrimitiveTypeChecker('symbol'),\n    any: createAnyTypeChecker(),\n    arrayOf: createArrayOfTypeChecker,\n    element: createElementTypeChecker(),\n    instanceOf: createInstanceTypeChecker,\n    node: createNodeChecker(),\n    objectOf: createObjectOfTypeChecker,\n    oneOf: createEnumTypeChecker,\n    oneOfType: createUnionTypeChecker,\n    shape: createShapeTypeChecker,\n    exact: createStrictShapeTypeChecker\n  };\n  /**\n   * inlined Object.is polyfill to avoid requiring consumers ship their own\n   * https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object/is\n   */\n\n  /*eslint-disable no-self-compare*/\n\n  function is(x, y) {\n    // SameValue algorithm\n    if (x === y) {\n      // Steps 1-5, 7-10\n      // Steps 6.b-6.e: +0 != -0\n      return x !== 0 || 1 / x === 1 / y;\n    } else {\n      // Step 6.a: NaN == NaN\n      return x !== x && y !== y;\n    }\n  }\n  /*eslint-enable no-self-compare*/\n\n  /**\n   * We use an Error-like object for backward compatibility as people may call\n   * PropTypes directly and inspect their output. However, we don't use real\n   * Errors anymore. We don't inspect their stack anyway, and creating them\n   * is prohibitively expensive if they are created too often, such as what\n   * happens in oneOfType() for any type before the one that matched.\n   */\n\n\n  function PropTypeError(message) {\n    this.message = message;\n    this.stack = '';\n  } // Make `instanceof Error` still work for returned errors.\n\n\n  PropTypeError.prototype = Error.prototype;\n\n  function createChainableTypeChecker(validate) {\n    {\n      var manualPropTypeCallCache = {};\n      var manualPropTypeWarningCount = 0;\n    }\n\n    function checkType(isRequired, props, propName, componentName, location, propFullName, secret) {\n      componentName = componentName || ANONYMOUS;\n      propFullName = propFullName || propName;\n\n      if (secret !== ReactPropTypesSecret_1) {\n        if (throwOnDirectAccess) {\n          // New behavior only for users of `prop-types` package\n          var err = new Error('Calling PropTypes validators directly is not supported by the `prop-types` package. ' + 'Use `PropTypes.checkPropTypes()` to call them. ' + 'Read more at http://fb.me/use-check-prop-types');\n          err.name = 'Invariant Violation';\n          throw err;\n        } else if (typeof console !== 'undefined') {\n          // Old behavior for people using React.PropTypes\n          var cacheKey = componentName + ':' + propName;\n\n          if (!manualPropTypeCallCache[cacheKey] && // Avoid spamming the console because they are often not actionable except for lib authors\n          manualPropTypeWarningCount < 3) {\n            printWarning$1('You are manually calling a React.PropTypes validation ' + 'function for the `' + propFullName + '` prop on `' + componentName + '`. This is deprecated ' + 'and will throw in the standalone `prop-types` package. ' + 'You may be seeing this warning due to a third-party PropTypes ' + 'library. See https://fb.me/react-warning-dont-call-proptypes ' + 'for details.');\n            manualPropTypeCallCache[cacheKey] = true;\n            manualPropTypeWarningCount++;\n          }\n        }\n      }\n\n      if (props[propName] == null) {\n        if (isRequired) {\n          if (props[propName] === null) {\n            return new PropTypeError('The ' + location + ' `' + propFullName + '` is marked as required ' + ('in `' + componentName + '`, but its value is `null`.'));\n          }\n\n          return new PropTypeError('The ' + location + ' `' + propFullName + '` is marked as required in ' + ('`' + componentName + '`, but its value is `undefined`.'));\n        }\n\n        return null;\n      } else {\n        return validate(props, propName, componentName, location, propFullName);\n      }\n    }\n\n    var chainedCheckType = checkType.bind(null, false);\n    chainedCheckType.isRequired = checkType.bind(null, true);\n    return chainedCheckType;\n  }\n\n  function createPrimitiveTypeChecker(expectedType) {\n    function validate(props, propName, componentName, location, propFullName, secret) {\n      var propValue = props[propName];\n      var propType = getPropType(propValue);\n\n      if (propType !== expectedType) {\n        // `propValue` being instance of, say, date/regexp, pass the 'object'\n        // check, but we can offer a more precise error message here rather than\n        // 'of type `object`'.\n        var preciseType = getPreciseType(propValue);\n        return new PropTypeError('Invalid ' + location + ' `' + propFullName + '` of type ' + ('`' + preciseType + '` supplied to `' + componentName + '`, expected ') + ('`' + expectedType + '`.'));\n      }\n\n      return null;\n    }\n\n    return createChainableTypeChecker(validate);\n  }\n\n  function createAnyTypeChecker() {\n    return createChainableTypeChecker(emptyFunctionThatReturnsNull);\n  }\n\n  function createArrayOfTypeChecker(typeChecker) {\n    function validate(props, propName, componentName, location, propFullName) {\n      if (typeof typeChecker !== 'function') {\n        return new PropTypeError('Property `' + propFullName + '` of component `' + componentName + '` has invalid PropType notation inside arrayOf.');\n      }\n\n      var propValue = props[propName];\n\n      if (!Array.isArray(propValue)) {\n        var propType = getPropType(propValue);\n        return new PropTypeError('Invalid ' + location + ' `' + propFullName + '` of type ' + ('`' + propType + '` supplied to `' + componentName + '`, expected an array.'));\n      }\n\n      for (var i = 0; i < propValue.length; i++) {\n        var error = typeChecker(propValue, i, componentName, location, propFullName + '[' + i + ']', ReactPropTypesSecret_1);\n\n        if (error instanceof Error) {\n          return error;\n        }\n      }\n\n      return null;\n    }\n\n    return createChainableTypeChecker(validate);\n  }\n\n  function createElementTypeChecker() {\n    function validate(props, propName, componentName, location, propFullName) {\n      var propValue = props[propName];\n\n      if (!isValidElement(propValue)) {\n        var propType = getPropType(propValue);\n        return new PropTypeError('Invalid ' + location + ' `' + propFullName + '` of type ' + ('`' + propType + '` supplied to `' + componentName + '`, expected a single ReactElement.'));\n      }\n\n      return null;\n    }\n\n    return createChainableTypeChecker(validate);\n  }\n\n  function createInstanceTypeChecker(expectedClass) {\n    function validate(props, propName, componentName, location, propFullName) {\n      if (!(props[propName] instanceof expectedClass)) {\n        var expectedClassName = expectedClass.name || ANONYMOUS;\n        var actualClassName = getClassName(props[propName]);\n        return new PropTypeError('Invalid ' + location + ' `' + propFullName + '` of type ' + ('`' + actualClassName + '` supplied to `' + componentName + '`, expected ') + ('instance of `' + expectedClassName + '`.'));\n      }\n\n      return null;\n    }\n\n    return createChainableTypeChecker(validate);\n  }\n\n  function createEnumTypeChecker(expectedValues) {\n    if (!Array.isArray(expectedValues)) {\n      printWarning$1('Invalid argument supplied to oneOf, expected an instance of array.');\n      return emptyFunctionThatReturnsNull;\n    }\n\n    function validate(props, propName, componentName, location, propFullName) {\n      var propValue = props[propName];\n\n      for (var i = 0; i < expectedValues.length; i++) {\n        if (is(propValue, expectedValues[i])) {\n          return null;\n        }\n      }\n\n      var valuesString = JSON.stringify(expectedValues);\n      return new PropTypeError('Invalid ' + location + ' `' + propFullName + '` of value `' + propValue + '` ' + ('supplied to `' + componentName + '`, expected one of ' + valuesString + '.'));\n    }\n\n    return createChainableTypeChecker(validate);\n  }\n\n  function createObjectOfTypeChecker(typeChecker) {\n    function validate(props, propName, componentName, location, propFullName) {\n      if (typeof typeChecker !== 'function') {\n        return new PropTypeError('Property `' + propFullName + '` of component `' + componentName + '` has invalid PropType notation inside objectOf.');\n      }\n\n      var propValue = props[propName];\n      var propType = getPropType(propValue);\n\n      if (propType !== 'object') {\n        return new PropTypeError('Invalid ' + location + ' `' + propFullName + '` of type ' + ('`' + propType + '` supplied to `' + componentName + '`, expected an object.'));\n      }\n\n      for (var key in propValue) {\n        if (propValue.hasOwnProperty(key)) {\n          var error = typeChecker(propValue, key, componentName, location, propFullName + '.' + key, ReactPropTypesSecret_1);\n\n          if (error instanceof Error) {\n            return error;\n          }\n        }\n      }\n\n      return null;\n    }\n\n    return createChainableTypeChecker(validate);\n  }\n\n  function createUnionTypeChecker(arrayOfTypeCheckers) {\n    if (!Array.isArray(arrayOfTypeCheckers)) {\n      printWarning$1('Invalid argument supplied to oneOfType, expected an instance of array.');\n      return emptyFunctionThatReturnsNull;\n    }\n\n    for (var i = 0; i < arrayOfTypeCheckers.length; i++) {\n      var checker = arrayOfTypeCheckers[i];\n\n      if (typeof checker !== 'function') {\n        printWarning$1('Invalid argument supplied to oneOfType. Expected an array of check functions, but ' + 'received ' + getPostfixForTypeWarning(checker) + ' at index ' + i + '.');\n        return emptyFunctionThatReturnsNull;\n      }\n    }\n\n    function validate(props, propName, componentName, location, propFullName) {\n      for (var i = 0; i < arrayOfTypeCheckers.length; i++) {\n        var checker = arrayOfTypeCheckers[i];\n\n        if (checker(props, propName, componentName, location, propFullName, ReactPropTypesSecret_1) == null) {\n          return null;\n        }\n      }\n\n      return new PropTypeError('Invalid ' + location + ' `' + propFullName + '` supplied to ' + ('`' + componentName + '`.'));\n    }\n\n    return createChainableTypeChecker(validate);\n  }\n\n  function createNodeChecker() {\n    function validate(props, propName, componentName, location, propFullName) {\n      if (!isNode(props[propName])) {\n        return new PropTypeError('Invalid ' + location + ' `' + propFullName + '` supplied to ' + ('`' + componentName + '`, expected a ReactNode.'));\n      }\n\n      return null;\n    }\n\n    return createChainableTypeChecker(validate);\n  }\n\n  function createShapeTypeChecker(shapeTypes) {\n    function validate(props, propName, componentName, location, propFullName) {\n      var propValue = props[propName];\n      var propType = getPropType(propValue);\n\n      if (propType !== 'object') {\n        return new PropTypeError('Invalid ' + location + ' `' + propFullName + '` of type `' + propType + '` ' + ('supplied to `' + componentName + '`, expected `object`.'));\n      }\n\n      for (var key in shapeTypes) {\n        var checker = shapeTypes[key];\n\n        if (!checker) {\n          continue;\n        }\n\n        var error = checker(propValue, key, componentName, location, propFullName + '.' + key, ReactPropTypesSecret_1);\n\n        if (error) {\n          return error;\n        }\n      }\n\n      return null;\n    }\n\n    return createChainableTypeChecker(validate);\n  }\n\n  function createStrictShapeTypeChecker(shapeTypes) {\n    function validate(props, propName, componentName, location, propFullName) {\n      var propValue = props[propName];\n      var propType = getPropType(propValue);\n\n      if (propType !== 'object') {\n        return new PropTypeError('Invalid ' + location + ' `' + propFullName + '` of type `' + propType + '` ' + ('supplied to `' + componentName + '`, expected `object`.'));\n      } // We need to check all keys in case some are required but missing from\n      // props.\n\n\n      var allKeys = objectAssign({}, props[propName], shapeTypes);\n\n      for (var key in allKeys) {\n        var checker = shapeTypes[key];\n\n        if (!checker) {\n          return new PropTypeError('Invalid ' + location + ' `' + propFullName + '` key `' + key + '` supplied to `' + componentName + '`.' + '\\nBad object: ' + JSON.stringify(props[propName], null, '  ') + '\\nValid keys: ' + JSON.stringify(Object.keys(shapeTypes), null, '  '));\n        }\n\n        var error = checker(propValue, key, componentName, location, propFullName + '.' + key, ReactPropTypesSecret_1);\n\n        if (error) {\n          return error;\n        }\n      }\n\n      return null;\n    }\n\n    return createChainableTypeChecker(validate);\n  }\n\n  function isNode(propValue) {\n    switch (typeof propValue) {\n      case 'number':\n      case 'string':\n      case 'undefined':\n        return true;\n\n      case 'boolean':\n        return !propValue;\n\n      case 'object':\n        if (Array.isArray(propValue)) {\n          return propValue.every(isNode);\n        }\n\n        if (propValue === null || isValidElement(propValue)) {\n          return true;\n        }\n\n        var iteratorFn = getIteratorFn(propValue);\n\n        if (iteratorFn) {\n          var iterator = iteratorFn.call(propValue);\n          var step;\n\n          if (iteratorFn !== propValue.entries) {\n            while (!(step = iterator.next()).done) {\n              if (!isNode(step.value)) {\n                return false;\n              }\n            }\n          } else {\n            // Iterator will provide entry [k,v] tuples rather than values.\n            while (!(step = iterator.next()).done) {\n              var entry = step.value;\n\n              if (entry) {\n                if (!isNode(entry[1])) {\n                  return false;\n                }\n              }\n            }\n          }\n        } else {\n          return false;\n        }\n\n        return true;\n\n      default:\n        return false;\n    }\n  }\n\n  function isSymbol(propType, propValue) {\n    // Native Symbol.\n    if (propType === 'symbol') {\n      return true;\n    } // 19.4.3.5 Symbol.prototype[@@toStringTag] === 'Symbol'\n\n\n    if (propValue['@@toStringTag'] === 'Symbol') {\n      return true;\n    } // Fallback for non-spec compliant Symbols which are polyfilled.\n\n\n    if (typeof Symbol === 'function' && propValue instanceof Symbol) {\n      return true;\n    }\n\n    return false;\n  } // Equivalent of `typeof` but with special handling for array and regexp.\n\n\n  function getPropType(propValue) {\n    var propType = typeof propValue;\n\n    if (Array.isArray(propValue)) {\n      return 'array';\n    }\n\n    if (propValue instanceof RegExp) {\n      // Old webkits (at least until Android 4.0) return 'function' rather than\n      // 'object' for typeof a RegExp. We'll normalize this here so that /bla/\n      // passes PropTypes.object.\n      return 'object';\n    }\n\n    if (isSymbol(propType, propValue)) {\n      return 'symbol';\n    }\n\n    return propType;\n  } // This handles more types than `getPropType`. Only used for error messages.\n  // See `createPrimitiveTypeChecker`.\n\n\n  function getPreciseType(propValue) {\n    if (typeof propValue === 'undefined' || propValue === null) {\n      return '' + propValue;\n    }\n\n    var propType = getPropType(propValue);\n\n    if (propType === 'object') {\n      if (propValue instanceof Date) {\n        return 'date';\n      } else if (propValue instanceof RegExp) {\n        return 'regexp';\n      }\n    }\n\n    return propType;\n  } // Returns a string that is postfixed to a warning about an invalid type.\n  // For example, \"undefined\" or \"of type array\"\n\n\n  function getPostfixForTypeWarning(value) {\n    var type = getPreciseType(value);\n\n    switch (type) {\n      case 'array':\n      case 'object':\n        return 'an ' + type;\n\n      case 'boolean':\n      case 'date':\n      case 'regexp':\n        return 'a ' + type;\n\n      default:\n        return type;\n    }\n  } // Returns class name of the object, if any.\n\n\n  function getClassName(propValue) {\n    if (!propValue.constructor || !propValue.constructor.name) {\n      return ANONYMOUS;\n    }\n\n    return propValue.constructor.name;\n  }\n\n  ReactPropTypes.checkPropTypes = checkPropTypes_1;\n  ReactPropTypes.PropTypes = ReactPropTypes;\n  return ReactPropTypes;\n};\n\nvar propTypes = createCommonjsModule(function (module) {\n  /**\n   * Copyright (c) 2013-present, Facebook, Inc.\n   *\n   * This source code is licensed under the MIT license found in the\n   * LICENSE file in the root directory of this source tree.\n   */\n  {\n    var REACT_ELEMENT_TYPE = typeof Symbol === 'function' && Symbol.for && Symbol.for('react.element') || 0xeac7;\n\n    var isValidElement = function isValidElement(object) {\n      return typeof object === 'object' && object !== null && object.$$typeof === REACT_ELEMENT_TYPE;\n    }; // By explicitly using `prop-types` you are opting into new development behavior.\n    // http://fb.me/prop-types-in-prod\n\n\n    var throwOnDirectAccess = true;\n    module.exports = factoryWithTypeCheckers(isValidElement, throwOnDirectAccess);\n  }\n});\nvar classnames = createCommonjsModule(function (module) {\n  /*!\n    Copyright (c) 2017 Jed Watson.\n    Licensed under the MIT License (MIT), see\n    http://jedwatson.github.io/classnames\n  */\n\n  /* global define */\n  (function () {\n    var hasOwn = {}.hasOwnProperty;\n\n    function classNames() {\n      var classes = [];\n\n      for (var i = 0; i < arguments.length; i++) {\n        var arg = arguments[i];\n        if (!arg) continue;\n        var argType = typeof arg;\n\n        if (argType === 'string' || argType === 'number') {\n          classes.push(arg);\n        } else if (Array.isArray(arg) && arg.length) {\n          var inner = classNames.apply(null, arg);\n\n          if (inner) {\n            classes.push(inner);\n          }\n        } else if (argType === 'object') {\n          for (var key in arg) {\n            if (hasOwn.call(arg, key) && arg[key]) {\n              classes.push(key);\n            }\n          }\n        }\n      }\n\n      return classes.join(' ');\n    }\n\n    if (module.exports) {\n      classNames.default = classNames;\n      module.exports = classNames;\n    } else {\n      window.classNames = classNames;\n    }\n  })();\n}); // const optionalRequire = require(\"optional-require\")(require),\n//     reactFontAwesome = optionalRequire('@fortawesome/react-fontawesome'),\n//     core = optionalRequire('@fortawesome/fontawesome-svg-core'),\n//     fas = optionalRequire('@fortawesome/free-solid-svg-icons');\n// export const FontAwesomeIcon = reactFontAwesome && reactFontAwesome.FontAwesomeIcon,\n//     faMinusCircle = fas && fas.faMinusCircle, \n//     faPlusCircle = fas && fas.faPlusCircle;\n// if (core) {\n//     core.library.add(fas.faMinusCircle, fas.faPlusCircle);\n// }\n\nvar IconDefElTypes = [Number, Number, function (el) {\n  return Array.isArray(el) && el.every(function (str) {\n    return str && str.constructor === String;\n  });\n}, String, String];\n\nfunction mightBeFAIcon(obj) {\n  if (!obj) {\n    return false;\n  }\n\n  if (obj.constructor === String) {\n    return /^[a-z0-9][a-z0-9\\-]*$/i.test(obj);\n  }\n\n  if (Array.isArray(obj)) {\n    return obj.every(function (str) {\n      return str.constructor === String;\n    });\n  }\n\n  if (!(obj instanceof Object) || !obj.iconName) {\n    return false;\n  }\n\n  switch (obj.prefix) {\n    case 'fas':\n    case 'far':\n    case 'fab':\n      break;\n\n    default:\n      return false;\n  }\n\n  var iconDef = obj.icon;\n\n  if (!Array.isArray(iconDef) || iconDef.length !== 5) {\n    return false;\n  }\n\n  return iconDef.every(function (val, idx) {\n    if (idx === 2) {\n      return IconDefElTypes[2](val);\n    } else {\n      return val && val.constructor === IconDefElTypes[idx];\n    }\n  });\n}\n\nvar iconDefinitionPropType = propTypes.oneOfType([propTypes.string, propTypes.arrayOf(propTypes.string), propTypes.element, propTypes.shape({\n  prefix: propTypes.oneOf(['fas', 'fab', 'far', 'fal']).isRequired,\n  iconName: propTypes.string.isRequired,\n  icon: propTypes.array\n})]);\n\nfunction sandwich(value, min, max) {\n  return Math.max(min, Math.min(max, value));\n}\n\nfunction getUVals(props) {\n  var uMin = props.min === undefined ? -Infinity : props.min,\n      uMax = props.max === undefined ? Infinity : props.max,\n      uValue = props.value === undefined ? sandwich(0, uMin, uMax) : props.value;\n  return {\n    uMin: uMin,\n    uMax: uMax,\n    uValue: uValue\n  };\n}\n\nvar NumericUpDown =\n/*#__PURE__*/\nfunction (_PureComponent) {\n  _inherits(NumericUpDown, _PureComponent);\n\n  function NumericUpDown(props) {\n    var _this;\n\n    _classCallCheck(this, NumericUpDown);\n\n    _this = _possibleConstructorReturn(this, _getPrototypeOf(NumericUpDown).call(this, props));\n    _this.input = React__default.createRef();\n    _this.recursiveUpdates = 0;\n\n    var _getUVals = getUVals(props);\n\n    _this.state = {\n      targetValue: null,\n      unsetValue: props.value === undefined ? '' : null\n    };\n\n    if (props.value < props.min || props.value > props.max) {\n      _this.state.targetValue = props.value;\n    }\n\n    _this._incrementValue = _this._incrementValue.bind(_assertThisInitialized(_assertThisInitialized(_this)));\n    _this._decrementValue = _this._decrementValue.bind(_assertThisInitialized(_assertThisInitialized(_this)));\n    _this._setUnsetValue = _this._setUnsetValue.bind(_assertThisInitialized(_assertThisInitialized(_this)));\n    return _this;\n  }\n\n  _createClass(NumericUpDown, [{\n    key: \"componentDidUpdate\",\n    value: function componentDidUpdate(oldProps) {\n      var _this$props = this.props,\n          min = _this$props.min,\n          max = _this$props.max,\n          value = _this$props.value,\n          oldMin = oldProps.min,\n          oldMax = oldProps.max,\n          oldValue = oldProps.value,\n          target = this.state.targetValue;\n\n      if (target !== null) {\n        if (value !== oldValue && this.recursiveUpdates === 0) {\n          // user changed value manually\n          this.setState({\n            targetValue: null\n          });\n        } else if (min !== oldMin && min <= target && oldMin > target || max !== oldMax && max >= target && oldMax < target) {\n          this._updateValue(target);\n\n          this.setState({\n            targetValue: null\n          });\n          return;\n        }\n      }\n\n      if (oldValue == value && (oldMax !== max || oldMin !== min)) {\n        if (target === null) {\n          if (min > oldValue || max < oldValue) {\n            this.setState({\n              targetValue: oldValue\n            });\n          }\n        }\n\n        var _getUVals2 = getUVals(this.props),\n            uMin = _getUVals2.uMin,\n            uMax = _getUVals2.uMax;\n\n        if (oldMin !== min && min >= target) {\n          this._updateValue(Math.min(min, uMax));\n        } else if (oldMax !== max && max <= target) {\n          this._updateValue(Math.max(max, uMin));\n        } else if (oldMin > oldMax && (min <= value || max >= value)) {\n          if (value <= min) {\n            this._updateValue(min);\n          } else {\n            this._updateValue(max);\n          }\n        }\n      }\n    }\n  }, {\n    key: \"_updateValue\",\n    value: function _updateValue(val) {\n      if (val === this.props.value) {\n        return;\n      }\n\n      if (!this.props.onChange) {\n        if (this.props.value === undefined) {\n          this.setState({\n            unsetValue: val\n          });\n        }\n      } else {\n        this.recursiveUpdates++;\n        this.props.onChange(val);\n        this.recursiveUpdates--;\n      }\n    }\n  }, {\n    key: \"_incrementValue\",\n    value: function _incrementValue(then, e) {\n      if (!this.props.disabled) {\n        this.setState({\n          targetValue: null\n        });\n        var step = this.props.step;\n\n        if (this.props.value === undefined) {\n          var _getUVals3 = getUVals(this.props),\n              uValue = _getUVals3.uValue,\n              uMin = _getUVals3.uMin,\n              uMax = _getUVals3.uMax;\n\n          if (this.input.current && this.input.current.value === '') {\n            this._updateValue(sandwich(uValue + step, uMin, uMax));\n          } else if (this.input.current) {\n            var unsetValue = this.state.unsetValue;\n            unsetValue = unsetValue === '' ? uValue : unsetValue;\n\n            this._updateValue(Math.min(unsetValue + step, uMax));\n          } else {\n            throw new Error('Somehow this.input.current was not set.');\n          }\n        } else {\n          this._updateValue(Math.min(this.props.max, this.props.value + this.props.step));\n        }\n\n        if (then) {\n          then(e);\n        }\n      }\n    }\n  }, {\n    key: \"_decrementValue\",\n    value: function _decrementValue(then, e) {\n      if (!this.props.disabled) {\n        this.setState({\n          targetValue: null\n        });\n        var step = this.props.step;\n\n        if (this.props.value === undefined) {\n          var _getUVals4 = getUVals(this.props),\n              uValue = _getUVals4.uValue,\n              uMin = _getUVals4.uMin,\n              uMax = _getUVals4.uMax;\n\n          if (this.input.current && this.input.current.value === '') {\n            this._updateValue(sandwich(uValue - step, uMin, uMax));\n          } else if (this.input.current) {\n            var unsetValue = this.state.unsetValue;\n            unsetValue = unsetValue === '' ? uValue : unsetValue;\n\n            this._updateValue(Math.max(unsetValue - step, uMin));\n          } else {\n            throw new Error('Somehow this.input.current was not set.');\n          }\n        } else {\n          this._updateValue(Math.max(this.props.min, this.props.value - step));\n        }\n\n        if (then) {\n          then(e);\n        }\n      }\n    }\n  }, {\n    key: \"_setUnsetValue\",\n    value: function _setUnsetValue(e) {\n      this._updateValue(e.target.value);\n    }\n  }, {\n    key: \"render\",\n    value: function render() {\n      var _this$props2 = this.props,\n          iconColor = _this$props2.iconColor,\n          minusIcon = _this$props2.minusIcon,\n          plusIcon = _this$props2.plusIcon,\n          inputAlign = _this$props2.inputAlign,\n          inputColor = _this$props2.inputColor,\n          className = _this$props2.className,\n          allowManualInputWithNaNBounds = _this$props2.allowManualInputWithNaNBounds,\n          value = _this$props2.value,\n          min = _this$props2.min,\n          max = _this$props2.max,\n          disabled = _this$props2.disabled,\n          onChange = _this$props2.onChange,\n          divProps = _objectWithoutProperties(_this$props2, [\"iconColor\", \"minusIcon\", \"plusIcon\", \"inputAlign\", \"inputColor\", \"className\", \"allowManualInputWithNaNBounds\", \"value\", \"min\", \"max\", \"disabled\", \"onChange\"]),\n          inputProps = {\n        value: value,\n        min: min,\n        max: max,\n        disabled: disabled\n      },\n          _getIconStyles = getIconStyles(),\n          iconClass = _getIconStyles.className,\n          iconStyles = _getIconStyles.styles,\n          divClasses = ['d-flex', 'flex-nowrap', 'flex-row', 'align-items-center', 'numeric-up-down', disabled && 'disabled', className];\n\n      if (!allowManualInputWithNaNBounds && min >= max) {\n        inputProps.disabled = disabled = true;\n      }\n\n      minusIcon = this._createIconBtn(true, minusIcon, iconClass);\n      plusIcon = this._createIconBtn(false, plusIcon, iconClass);\n\n      if (value === undefined) {\n        inputProps.value = value === undefined ? this.state.unsetValue : value;\n        inputProps.onChange = this._setUnsetValue;\n      }\n\n      return React__default.createElement(\"div\", _extends({}, divProps, {\n        className: _JSXStyle.dynamic([[\"2780546048\", [this.props.inputAlign]]]) + \" \" + (divProps.className != null && divProps.className || classnames(divClasses) || \"\")\n      }), minusIcon, React__default.createElement(\"input\", _extends({\n        type: \"number\"\n      }, inputProps, {\n        ref: this.input,\n        className: _JSXStyle.dynamic([[\"2780546048\", [this.props.inputAlign]]]) + \" \" + (inputProps.className != null && inputProps.className || classnames('form-control mx-2', inputColor && \"text-\".concat(inputColor)) || \"\")\n      })), plusIcon, iconStyles, React__default.createElement(_JSXStyle, {\n        styleId: \"2780546048\",\n        css: \"input.__jsx-style-dynamic-selector{text-align:\".concat(this.props.inputAlign, \";-webkit-flex:1;-ms-flex:1;flex:1;-moz-appearance:textfield;}input.__jsx-style-dynamic-selector::-webkit-outer-spin-button,input.__jsx-style-dynamic-selector::-webkit-inner-spin-button{-webkit-appearance:none;margin:0;}\"),\n        dynamic: [this.props.inputAlign]\n      }));\n    }\n  }, {\n    key: \"_createIconBtn\",\n    value: function _createIconBtn(isMinus, icon, iconClass) {\n      var _this$props3 = this.props,\n          value = _this$props3.value,\n          min = _this$props3.min,\n          max = _this$props3.max,\n          disabled = _this$props3.disabled,\n          iconColor = _this$props3.iconColor,\n          iconDisabled = disabled || (isMinus ? value <= min : value >= max),\n          iconClasses = [isMinus ? 'minus-icon' : 'plus-icon', iconClass, iconDisabled && 'disabled'],\n          onClick = isMinus ? this._decrementValue : this._incrementValue;\n\n      if (iconColor instanceof Object) {\n        iconColor = \"text-\".concat(iconColor[isMinus ? 'minus' : 'plus']);\n      }\n\n      if (React__default.isValidElement(icon)) {\n        var props = {\n          className: classnames.apply(void 0, [icon.props.className, iconColor].concat(_toConsumableArray(iconClasses))),\n          onClick: onClick\n        };\n\n        if (icon.props.onClick) {\n          props.onClick = onClick.bind(this, icon.props.onClick);\n        }\n\n        return React__default.cloneElement(icon, props);\n      }\n\n      if (mightBeFAIcon(icon)) {\n        try {\n          return React__default.createElement(reactFontawesome.FontAwesomeIcon, {\n            icon: icon,\n            onClick: onClick.bind(this, null),\n            className: classnames.apply(void 0, [iconColor].concat(_toConsumableArray(iconClasses)))\n          });\n        } catch (_unused) {}\n      }\n\n      if (icon.constructor === String) {\n        iconClasses = iconClasses.concat(['btn', iconColor ? iconColor.replace('text-', 'btn-outline-') : 'btn-outline-secomdary']);\n        return React__default.createElement(\"div\", {\n          onClick: onClick.bind(this, null),\n          className: classNames(iconClasses)\n        }, icon);\n      } // should never get here, but just in case...\n\n\n      return icon;\n    }\n  }]);\n\n  return NumericUpDown;\n}(React.PureComponent);\n\n_defineProperty(NumericUpDown, \"propTypes\", {\n  inputColor: propTypes.oneOfType([propTypes.string, propTypes.shape({\n    minus: propTypes.string.isRequired,\n    plus: propTypes.string.isRequired\n  })]),\n  iconColor: propTypes.string,\n  value: propTypes.number,\n  min: propTypes.number,\n  max: propTypes.number,\n  step: propTypes.number,\n  minusIcon: iconDefinitionPropType.isRequired,\n  plusIcon: iconDefinitionPropType.isRequired,\n  disabled: propTypes.bool,\n  onChange: propTypes.func,\n  inputAlign: propTypes.oneOf(['left', 'center', 'right']),\n  allowManualInputWithNaNBounds: propTypes.bool\n});\n\n_defineProperty(NumericUpDown, \"defaultProps\", {\n  minusIcon: freeSolidSvgIcons.faMinusCircle,\n  // (FontAwesomeIcon && faMinusCircle) ? faMinusCircle : '-',\n  plusIcon: freeSolidSvgIcons.faPlusCircle,\n  // (FontAwesomeIcon && faPlusCircle) ? faPlusCircle : '+',\n  inputAlign: 'center',\n  allowManualInputWithNaNBounds: false,\n  step: 1\n});\n\nfunction getIconStyles() {\n  return {\n    styles: React__default.createElement(_JSXStyle, {\n      styleId: \"1158657347\",\n      css: \".minus-icon.jsx-1158657347,.plus-icon.jsx-1158657347{cursor:pointer;}.minus-icon.disabled.jsx-1158657347,.plus-icon.disabled.jsx-1158657347,.disabled.jsx-1158657347 .minus-icon.jsx-1158657347,.disabled.jsx-1158657347 .plus-icon.jsx-1158657347{opacity:.65;cursor:default;}\"\n    }),\n    className: \"jsx-1158657347\"\n  };\n}\n\nmodule.exports = NumericUpDown;","map":null,"metadata":{},"sourceType":"script"}